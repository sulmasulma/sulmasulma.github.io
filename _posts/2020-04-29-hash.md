---
layout: post
title: 해시
tags: [Algorithm, Hash]
categories: [Algorithm]
excerpt_separator: <!--more-->
---
해시는 **Key-Value** 쌍으로 데이터를 저장하는 자료구조이다. 해시 알고리즘에 대한 예를 정리해 보았다.<!--more-->

### 완주하지 못한 선수
- [문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42576)
> 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 리턴하는 알고리즘. 완주하지 못한 선수는 단 한 명으로, completion의 길이는 participant보다 1 짧으며, 참가자 중에는 동명이인이 있을 수 있다.

첫 번째 예시는 participant에서 completion에 있는 사람들을 하나씩 뺀 것으로, 테스트 케이스에서 시간 초과(...)한 코드이다.
```python
def solution(participant, completion):
    for ele in completion:
        participant.remove(ele)
    return participant[0]
```
- `.remove`에서 participant의 값들 중에서 ele를 찾아서 제거해야 하기 때문에 속도가 느려지는 듯 하다.

다음 예시는 participant와 completion을 **정렬** 하고 순서가 맞지 않는 사람을 리턴하는 코드이다. `.sort`로 정렬하는 과정은 속도에 큰 영향을 미치지 않는 것으로 보인다.
```py
def solution(participant, completion):
    participant.sort()
    completion.sort()
    for p, c in zip(participant, completion):
        if p != c:
            return p # 마지막 참가자가 아닌 사람이 완주하지 못했을 경우
    return participant[-1] # 마지막 참가자가 완주하지 못했을 경우
```
- 마지막 참가자가 아닌 사람이 완주하지 못했을 경우 `return p`에서 리턴되고, 마지막 참가자가 완주하지 못했을 경우 `return participant[-1]`에서 리턴된다.

다음은 `hash` 함수를 사용한 예시이다. `hash(value)`는 value의 주소를 반환해 준다.
```py
def solution(participant, completion):
    answer = ''
    temp = 0
    dic = {}
    for part in participant:
        dic[hash(part)] = part
        temp += hash(part)
    for com in completion:
        temp -= hash(com)
    answer = dic[temp]

    return answer
```
- 해시가 Key-Value 쌍으로 데이터를 저장하는 자료구조라는 특성을 활용한 예이다. temp에 참가자들의 주소를 더한 후에 완주자들의 주소를 빼서 완주하지 못한 사람의 주소만 남기도록 해 준다.

<p>

### 전화번호 목록
- [문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42577)
> 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를, 그렇지 않으면 true를 리턴한다. 예를 들어 전화번호 목록이 ["123", "12345"]일 경우 "123"은 "12345"의 접두어이므로 false를 리턴한다.

첫 번째 예시는 phone_book의 각 요소(`a`)와 자기 자신을 뺀 요소(`b`) 중 자기보다 큰 요소를 비교하여, `a`가 `b`의 접두어이면 False를 리턴하는 함수이다.
```py
def solution(phone_book):
    for a in phone_book:
        for b in [ele for ele in phone_book if ele != a]:
            if len(b) >= len(a) and b[0:len(a)] == a: # 접두어이므로, 비교할 단어(b)의 길이가 더 길어야 함
                return False
    return True
```

다음 예시는 phone_book을 정렬한 경우이다. 전화번호들이 `string` 형식으로 주어지므로, 한 단어가 다른 단어의 접두어일 경우 **바로 다음 순서** 로 정렬되는 것을 활용한 것이다. 접두어를 확인하는 것은 `string.startswith` 메소드 이용하였다.
```py
def solution(phone_book):
    phone_book.sort()
    for p1, p2 in zip(phone_book, phone_book[1:]):
        if p2.startswith(p1): # 바로 다음 거랑만 비교
            return False
    return True
```

---
출처: [프로그래머스 해시 문제](https://programmers.co.kr/learn/courses/30/parts/12077)
